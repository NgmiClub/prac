MVM:
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity LCD_FSM is
Port (
    rst       : in  std_logic;   -- reset
    clk_12Mhz : in  std_logic;   -- high freq. clock
    lcd_rs    : out std_logic;   -- LCD RS control
    lcd_en    : out std_logic;   -- LCD Enable
    lcd_data  : out std_logic_vector(7 downto 0)  -- LCD Data port
);
end LCD_FSM;

architecture Behavioral of LCD_FSM is

    signal div       : std_logic_vector(15 downto 0); -- delay timer 1
    signal clk_fsm   : std_logic;
    signal lcd_rs_s  : std_logic; -- LCD controller FSM state output

    type state is (s_reset, func, mode, cur, clear, d0, d1, d2, d3, d4, hold);
    signal ps1, nx : state;

    signal dataout_s : std_logic_vector(7 downto 0); -- internal data/command multiplexer

begin
    ----- clk divider ---------------------------------
    process(rst, clk_12Mhz)
    begin
        if (rst = '1') then
            div <= (others => '0');
        elsif (clk_12Mhz'event and clk_12Mhz = '1') then
            div <= std_logic_vector(unsigned(div) + 1); -- safe increment
        end if;
    end process;
    ----------------------------------------------------

    clk_fsm <= div(15);

    ----- Present state Register -----------------------
    process(rst, clk_fsm)
    begin
        if (rst = '1') then
            ps1 <= s_reset;
        elsif rising_edge(clk_fsm) then
            ps1 <= nx;
        end if;
    end process;

    ----- state and output decoding process (combinational)
    process(ps1)
    begin
        -- default assignments (avoid latches)
        nx       <= ps1;               -- by default remain in same state
        lcd_rs_s <= '0';
        dataout_s <= (others => '0');

        case ps1 is

            when s_reset =>
                nx       <= func;
                lcd_rs_s <= '0';
                dataout_s <= "00111000";  -- 38h

            when func =>
                nx       <= mode;
                lcd_rs_s <= '0';
                dataout_s <= "00111000";  -- 38h

            when mode =>
                nx       <= cur;
                lcd_rs_s <= '0';
                dataout_s <= "00000110";  -- 06h

            when cur =>
                nx       <= clear;
                lcd_rs_s <= '0';
                dataout_s <= "00001100";  -- 0Ch

            when clear=>
                nx       <= d0;
                lcd_rs_s <= '0';
                dataout_s <= "00000001";  -- 01h

            when d0 =>
                lcd_rs_s <= '1';
                dataout_s <= "01010000";  -- 'P'
                nx <= d1;

            when d1 =>
                lcd_rs_s <= '1';
                dataout_s <= "01001001";  -- 'I'
                nx <= d2;

            when d2 =>
                lcd_rs_s <= '1';
                dataout_s <= "01000011";  -- 'C'
                nx <= d3;

            when d3 =>
                lcd_rs_s <= '1';
                dataout_s <= "01010100";  -- 'T'
                nx <= d4;

            when d4 =>
                lcd_rs_s <= '1';
                dataout_s <= "00100000";  -- space
                nx <= hold;

            when hold =>
                lcd_rs_s <= '0';
                dataout_s <= "00000000";  -- hold (all zeros)
                nx <= hold;

            when others =>
                nx       <= s_reset;
                lcd_rs_s <= '0';
                dataout_s <= "00000001";  -- CLEAR (01h)

        end case;
    end process;

    lcd_en   <= clk_fsm;
    lcd_rs   <= lcd_rs_s;
    lcd_data <= dataout_s;

end Behavioral;




TVM
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity LCD_Test is
end LCD_Test;

architecture behavior of LCD_Test is

    -- Component Declaration for the Unit Under Test (UUT)
    component LCD_FSM
        port(
            rst       : in  std_logic;
            clk_12Mhz : in  std_logic;
            lcd_rs    : out std_logic;
            lcd_en    : out std_logic;
            lcd_data  : out std_logic_vector(7 downto 0)
        );
    end component;

    -- Inputs
    signal rst       : std_logic := '0';
    signal clk_12Mhz : std_logic := '0';

    -- Outputs
    signal lcd_rs    : std_logic;
    signal lcd_en    : std_logic;
    signal lcd_data  : std_logic_vector(7 downto 0);

    -- Clock period definitions
    constant clk_12Mhz_period : time := 10 ns;

begin

    -- Instantiate the Unit Under Test (UUT)
    uut: LCD_FSM
        port map (
            rst       => rst,
            clk_12Mhz => clk_12Mhz,
            lcd_rs    => lcd_rs,
            lcd_en    => lcd_en,
            lcd_data  => lcd_data
        );

    -- Clock process
    clk_12Mhz_process : process
    begin
        clk_12Mhz <= '0';
        wait for clk_12Mhz_period / 2;
        clk_12Mhz <= '1';
        wait for clk_12Mhz_period / 2;
    end process;

    -- Stimulus process
    stim_proc: process
    begin
        rst <= '1';
        wait for 1 ms;      -- hold reset longer to allow divider to start
        rst <= '0';
        wait;               -- run indefinitely
    end process;

    -- Optional monitor
    monitor_proc: process(lcd_data)
    begin
        report "LCD Data changed to: " &
               integer'image(to_integer(unsigned(lcd_data)));
    end process;

end behavior;




UCF
NET "clk_12Mhz" LOC = P80; 
NET "rst" LOC = P204; 
NET "lcd_rs" LOC = P48; 
NET "lcd_en" LOC = P49; 
NET "lcd_data[0]" LOC = P47; 
NET "lcd_data[1]" LOC = P41; 
NET "lcd_data[2]" LOC = P39; 
NET "lcd_data[3]" LOC = P35; 
NET "lcd_data[4]" LOC = P33; 
NET "lcd_data[5]" LOC = P31; 
NET "lcd_data[6]" LOC = P29; 
NET "lcd_data[7]" LOC = P24; 